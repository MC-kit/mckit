.. _mcnp_transformation:

Трансформация геометрии
=======================

MCNP позволяет задать геометрию в такой системе координат (СК), в которой
геометрия задается в наиболее простом виде. Преобразование от специальной СК
к основной СК осуществляется с помощью *трансформации*. Трансформация
геометрии осуществляется с помощью двух операций: поворота СК и паралельного
переноса СК. В MCNP трансформация задается в виде [#mcman]_:

  \*TRn O\ :sub:`1` O\ :sub:`2` O\ :sub:`3` B\ :sub:`1` B\ :sub:`2` B\ :sub:`3`
  B\ :sub:`4` B\ :sub:`5` B\ :sub:`6` B\ :sub:`7` B\ :sub:`8` B\ :sub:`9` M

  * n - номер трансформации
  
  * O\ :sub:`1` O\ :sub:`2` O\ :sub:`3` - координаты вектора параллельного
    переноса системы координат
    
  * B\ :sub:`1` ... B\ :sub:`9` - задают матрицу вращения. xyz - оси основной
    системы координат; x'y'z' - оси вспомогательной системы координат.
    B\ :sub:`1` ... B\ :sub:`9` - это либо углы между соответствующими осями,
    либо косинусы этих углов.
  
    +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
    | B\ :sub:`1` | B\ :sub:`2` | B\ :sub:`3` | B\ :sub:`4` | B\ :sub:`5` | B\ :sub:`6` | B\ :sub:`7` | B\ :sub:`8` | B\ :sub:`9` |
    +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
    | x'x         | x'y         | x'z         | y'x         | y'y         | y'z         | z'x         | z'y         | z'z         |
    +-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
    
  * M - флаг, показывающий как интерпредировать координаты вектора
    параллельного переноса. Если 1 (значение по умолчанию), то это координаты
    начала вспомогательной СК, заданные в основной СК. Если -1, то это
    коодринаты начала основной СК, заданные во вспомогательной СК.
    
  * \* - если присутствует, то B\ :sub:`1` ... B\ :sub:`9` заданы в градусах;
    в противном случае это косинуcы углов.
    
В MCNP не обязательно задавать все девять параметров матрицы поворота. Возможны
следующие варианты:

* Заданы орты только двух осей (6 значений). Оставщиеся параметры будут
  получены как векторное произведение этих двух векторов.
  
* 5 значений.

  .. warning:: Не реализовано.
  
* Один вектор (3 значения). Остальные два орта создаются произвольно,
  перпендикулярно первому.
  
* Ни одного значения - соответствует параллельному переносу. Матрица вращения -
  единичная матрица.
    
Преобразование координат
------------------------
    
Пусть *xyz* - основная система координат с базисом :math:`\mathbf{e}_x,
\mathbf{e}_y, \mathbf{e}_z`. *x'y'z'* - вспомогательная СК с базисом
:math:`\mathbf{e}'_x, \mathbf{e}'_y, \mathbf{e}'_z`.  :math:`\mathbf{T}
= \{x_0, y_0, z_0\}` - координаты начала вспомогательной системы отсчета,
заданные в основной СК.

Запишем базисные векторы вспомогательной СК в базисе основной СК:

.. math::

   \mathbf{e}'_x &= \{cos(x'x), & cos(x'y), & cos(x'z)\}\\
   \mathbf{e}'_y &= \{cos(y'x), & cos(y'y), & cos(y'z)\}\\
   \mathbf{e}'_z &= \{cos(z'x), & cos(z'y), & cos(z'z)\}

Тогда, записывая координаты этих векторов по столбцам, получим матрицу
поворота (является ортогональной):

.. math::

   U = \begin{Vmatrix} cos(x'x) & cos(y'x) & cos(z'x) \\
   cos(x'y) & cos(y'y) & cos(z'y) \\
   cos(x'z) & cos(y'z) & cos(z'z)\end{Vmatrix}
        
Пусть :math:`\mathbf{r'}=\{x', y', z'\}` - радиус-вектор некоторой точки во
вспомогательной СК. Тогда радиус-вектор этой точки в основной СК примет вид:

.. math::
   :label: trpoint
   
   \mathbf{r} &= U \mathbf{r'} + \mathbf{T}
   
Обращая это выражение, получим формулу для обратного преобразования:

.. math::
   
   \mathbf{r'} &= U^T (\mathbf{r} - \mathbf{T})

Если ввести обозначения

.. math::
   :label: invtr
   
   U'&=U^T\\\mathbf{T}'&=-U^T\mathbf{T}
   
то получим формулу для обратного преобразования в виде :eq:`trpoint`. Таким 
образом матрица вращения и вектор смещения для трансформации, обратной к данной 
определяются по формуле :eq:`invtr`.
Начало основной СК в ней самой же является нулевым вектором :math:`\theta`.
Координаты этой же точки во вспомогательной СК задаются вектором
:math:`\mathbf{T'}` (см. случай, когда в карте TR M=-1). Тогда

.. math::

   \mathbf{T'} &= -U^T \mathbf{T}\\
   \mathbf{T} &= -U \mathbf{T'}
   
Объект трансформации хранит матрицу :math:`U` и вектор :math:`\mathbf{T}`.

Комбинация трансформаций
------------------------

Рассмотрим случай, когда есть более одной специальной системы координат. Пусть
есть лабораторная система координат :math:`xyz`, и две специальных системы 
:math:`x'y'z'` и :math:`x''y''z''`. Причем задано преобразование из первой 
специальной системы координат в основную с помощью матрицы вращения :math:`U_1`
и вектора смещения :math:`\mathbf{T}_1`, и преобразование из второй специальной
СК в первую задано матрицей :math:`U_2` и вектором :math:`T_2`, т.е.

.. math:: 
 
   \mathbf{r}&=U_1 \mathbf{r}'+\mathbf{T}_1\\
   \mathbf{r}'&=U_2 \mathbf{r}''+\mathbf{T}_2
   
Найдем преобразование из второй специальной системы координат в лабораторную.
Ддя этого подставим второй уравнение в первое:

.. math:: \mathbf{r}=U_1 U_2 \mathbf{r}''+U_1 \mathbf{T}_2 + \mathbf{T}_1

Введя соответствующие обозначения, получим:

.. math:: 
   :label: trtr

   \mathbf{r}&=U \mathbf{r}''+\mathbf{T}\\U&=U_1U_2\\
   \mathbf{T}&=U_1\mathbf{T}_2+\mathbf{T}_1

Задание матрицы вращения
------------------------

Матрица вращения определяется базисными векторами вспомогательной системы
координат. Как было указано выше, параметры матрицы вращения могут быть заданы
двумя способами:

* это углы между базисным вектором вспомогательной системы координат и всеми
  осями основной системы координат, заданные в градусах;
  
* это косинусы углов между базисными векторами вспомогательной системы
  координат и осями основной системы координат - фактически это координаты
  базисных векторов вспомогательной системы координат, заданные в основной
  системе.
  
В таком виде их принемает MCNP. При этом, если имеет место быть небольшая
неортогональность базисных векторов, MCNP производит ортогонализацию матрицы
вращения; если неортогональность превышает 0.001 радиан - выдается
предупреждение. В своей реализации *объекта трансформации* сделаем еще одно
допущение: базисные вектора не обязаны быть нормированными на единицу -
нормировка будет произведена в конструкторе объекта. Для ортогонализации базиса
применим процесс
`Грама-Шмидта <https://ru.wikipedia.org/wiki/Процесс_Грама_―_Шмидта>`_:

.. math::
   :label: gram_shmidt

   \mathbf{e}_{z1} &= \mathbf{e}_z\\
   \mathbf{e}_{x1} &= \frac{\mathbf{e}_x - \mathbf{e}_{z1} (\mathbf{e}_{z1},
   \mathbf{e}_x)}{\sqrt{1 - (\mathbf{e}_{z1}, \mathbf{e}_x)^2}}\\
   \mathbf{e}_{y1} &= \frac{\mathbf{e}_y - \mathbf{e}_{z1} (\mathbf{e}_{z1},
   \mathbf{e}_y) - \mathbf{e}_{x1} (\mathbf{e}_{x1}, \mathbf{e}_y)}
   {\sqrt{1 - (\mathbf{e}_{z1}, \mathbf{e}_y)^2 - (\mathbf{e}_{x1},
   \mathbf{e}_y)^2}}
   
Вектора :math:`\mathbf{e}_{x1}, \mathbf{e}_{y1}, \mathbf{e}_{z1}` далее
используются в качестве базиса вспомогательной системы координат, и служат для
задания матрицы вращения. В случае, если неортогональность какой-либо из пар
базисных векторов более 0.001 радиан, то генерится исключение.

Построение базиса, если известен один базисный вектор
-----------------------------------------------------

Пусть есть базис :math:`\mathbf{e}_x`, :math:`\mathbf{e}_y`, :math:`\mathbf{e}_z`.
Пусть в нем определен некоторый единичный вектор :math:`\mathbf{v}`, который
задает направление одного из ортов некоторого нового ортонормированного базиса
:math:`\mathbf{e}'_z`. Найдем остальные векторы :math:`\mathbf{e}'_x` и 
:math:`\mathbf{e}'_y`. Для этого определим вектора :math:`\mathbf{n}_x=
[\mathbf{e}_x, \mathbf{v}]`, :math:`\mathbf{n}_y=[\mathbf{e}_y, \mathbf{v}]` и 
:math:`\mathbf{n}_z=[\mathbf{e}_z, \mathbf{v}]`, которые перпендикулярны вектору
:math:`\mathbf{v}` и, векторам :math:`\mathbf{e}_x`, :math:`\mathbf{e}_y`, 
:math:`\mathbf{e}_z` соответственно. Из них выберем вектор с наибольшей длиной
в качестве одного из векторов нового базиса - :math:`\mathbf{e}'_x`. 
Это необходимо на случай, когда вектор :math:`\mathbf{v}` совпадает (или почти
совпадает) с одной из осей координат: соответствующее векторное произведение 
равно 0. Оставшийся базисный вектор найдем как векторное произведение уже двух
найденных. Тогда имеем

.. math::

   \DeclareMathOperator*{\argmax}{argmax}
   \mathbf{e}'_z&=\mathbf{v}\\
   \mathbf{e}'_x&=\argmax\limits_{\substack{\mathbf{n}\in\{\mathbf{n}_x, \mathbf{n}_y, 
   \mathbf{n}_z\}}}{|\mathbf{n}|}\\\mathbf{e}'_y&=[\mathbf{e}'_z, \mathbf{e}'_x]
   
Для полученных векторов необходимо произвести ортогонализацию. Здесь также 
важно, что именно :math:`\mathbf{e}'_z` определяется как вектор, сонаправленный
с :math:`\mathbf{v}`: в случае ортогонализации (см. :eq:`gram_shmidt`) именно 
:math:`\mathbf{e}_z` остается неизменным, а вектор :math:`\mathbf{v}` определен 
и не должен меняться.

.. _transform_equality:

Равенство трансформаций
-----------------------

Рассмотрим условия при которых две трансформации можно считать одинаковыми. 
Пусть область пространства :math:`B` в которой рассматриваются трансформации 
ограничена прямоугольным параллепипедом со сторанами, параллельными осям 
координат (bounding box). Пусть координаты точек, попадающих в этот 
параллепипед задаются радиус-вектором :math:`\mathbf{r}=\{x,y,z\}`, причем 
:math:`x\in[x_a,x_b]`, :math:`y\in[y_a,y_b]`, :math:`z\in[z_a, z_b]`. Пусть 
максимальное расстояние между двумя точками, при котором эти точки считаются 
одинаковыми равно :math:`\delta r`. Пусть также есть две трансформации

.. math:: \mathbf{r}_1&=U_1\mathbf{r}'_1+\mathbf{T}_1\\
   \mathbf{r}_2&=U_2\mathbf{r}'_2+\mathbf{T}_2
   
Выразим радиус векторы со штрихами:

.. math:: \mathbf{r}'_1=U^T_1(\mathbf{r}-\mathbf{T}_1)\\
   \mathbf{r}'_2=U^T_2(\mathbf{r}-\mathbf{T}_2)
   
Здесь в обоих выражениях присутствует :math:`\mathbf{r}`. Это сделано по 
следующей причине: если эти трансформации переводят одну и ту же произвольную
точку в лабораторной системе координат в точки :math:`\mathbf{r}'_1` и 
:math:`\mathbf{r}'_2` такие, что расстояние между ними не превышает 
:math:`\delta r`, то эти трансформации будем считать эквивалентными. Каждая
трансформация состоит из вращения и параллельного переноса. Вращение 
рассматривается относительно начала вспомогательной системы координат, которое
задается вектором параллельного переноса. Тогда, чтобы две трансформации были
одинаковыми необходимо, чтобы начала соответствующих вспомогательных систем
координат совпадали, т.е. :math:`|\mathbf{T}_1-\mathbf{T}_2|<\delta r`. Если 
это условие выполнено, то различие заключается только в матрицах вращения. 
Вращение приводит к повороту любой прямой, проходящей через точку вращения на
некоторый угол. Соответственно расстояние между результатами вращения одной и 
той же точки с помощью разных матриц поворота будет тем больше, чем дальше эта
точка находится от центра вращения. Тогда трансформации равны, если самая 
далекая от центра вращения точка в результате вращения переходит в точки, 
находящиеся на расстоянии не превышающем :math:`\delta r`. Пусть :math:`P_B` -
множество вершин параллепипеда :math:`B`. Тогда условие равенства трансформаций
можно записать в виде

.. math::
   
   \begin{cases}
   &\mathbf{r}_m=\argmax\limits_{\substack{\mathbf{r}\in P_B}}{|\mathbf{r}-
   \mathbf{T}_1|}\\
   &|\mathbf{T}_1-\mathbf{T}_2|<\delta r\\
   &\left|(U^T_1-U^T_2)\mathbf{r}_m+U^T_2\mathbf{T}_2-U^T_1\mathbf{T}_1\right|
   <\delta r
   \end{cases}

.. _mcnp_transform_eq:

Преобразование уравнения поверхности
------------------------------------

Рассмотрим общее уравнение :ref:`поверхности <mcnp_surf_eq>` 2-го порядка,
заданное в специальной СК:

.. math:: S(\mathbf{R'}) = \mathbf{R'}^T M' \mathbf{R'} + \mathbf{V'}^T \mathbf{R'} + K'
   
Здесь :math:`M'` - симметричная матрица (это важно, т.к. далее в выкладках
это свойство приводит к тому, что :math:`M'^T = M'`), :math:`\mathbf{V'}` -
вектор, :math:`K'` - скаляр. Заменим :math:`\mathbf{R'}` на :math:`\mathbf{R}`
воспользовавшись формулой :eq:`trpoint`, получим

.. math:: S(\mathbf{R}) = \mathbf{R}^T M \mathbf{R} + \mathbf{V}^T \mathbf{R} + K,
   :label: tgq

где

.. math::
   :label: tr_gq_params
   
   M &= U M' U^T\\
   \mathbf{V} &= U \mathbf{V'} - 2 M \mathbf{T}\\
   K &= K' - \mathbf{V}^T \mathbf{T} - \mathbf{T}^T M \mathbf{T}
   
Почти все поверхности в MCNP (кроме тора) можно описать общей поверхностью 2-го
порядка. Но в качестве особых случаев можно выделить плоскость и сферу.

* Плоскость при любых преобразованиях переходит в плоскость. При этом плоскость
  можно описать уравнением :eq:`tgq`, если положить матрицу :math:`M` нулевой,
  и производить преобразование ее параметров по формуле :eq:`tr_gq_params`.

* Сфера также всегда переходит в сферу. При этом меняются только координаты ее
  центра. Соответственно для преобразования параметров сферы достаточно
  применения формулы :eq:`trpoint` к координатам ее центра.
  
* Тор является поверхностью 4-го порядка, и в MCNP на его параметры наложены
  ограничения: ось тора может быть только параллельна осям главной СК, и
  разрешены только такие преобразования, которые оставляют его ось симметрии
  параллельной любой из осей главной СК. Поэтому при преобразовании координат
  у тора меняются только координаты его центра и вектор оси. Т.о. новые
  параметры тора определяются по формулам :eq:`trpoint`, :eq:`tr_gq_params`.

.. seealso::

   :class:`класс Transform <geometry.transform.Transform>`
  
Литература
----------

.. [#mcman] MCNP - A General Monte Carlo N-Partical Transport Code, Version 5.
   Volume II: User's Guide, 2003