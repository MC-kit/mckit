.. _tutorial:

Руководство пользователя
========================

Введение
--------

Пакет mckit предназначен для облегчения работы с кодами для проведения расчета
радиационного транспорта и активации материалов, такими как MCNP, FISPACT.
а также для позволяет упростиь процесс анализа полученных результатов. Основные
возможности пакета:

* Упрощение процесса редактирования интеграции сложных моделей

* Упрощение геометрического описания ячеек, определение пустых ячеек

* Обработка результатов расчетов нейтронного и гамма потоков, радиационного
  нагрева

* Автоматизация расчета активации материалов для заданного сценария облучения

* Формирование пространственного гамма-источника для расчета SDDR (Shutdown
  dose rate)

Для работы с пакетом необходимо базовое знание языка
`Python <https://www.python.org/>`_, а также библиотек `numpy <www.numpy.org/>`_
и `matplotlib <https://matplotlib.org/>`_. Для более удобной работы предлагается
использовать `Jupyter Notebook <http://jupyter.org/>`_.

Установка
---------

Пока еще не понятно до конца, сам не ставил.

Начало работы
-------------

Существенная часть классов, представленных в mckit имеет однозначное
соответствие с сущностями в MCNP. Чтобы начать работу, необходимо импортировать
пакет::

    import mckit as mc

Везде далее будет предполагаться, что была выполнена эта операция.

Главным классом является :code:`mc.Universe`, который соответствует юнивёрсу в
MCNP и, фактически, представляет саму модель. Через объект этого класса будут
доступны другие (вложенные) юниверсы, ячейки, поверхности, материалы, и др.

Также :code:`mckit` включает следующие классы для работы:

* :code:`Element`, :code:`Material`, :code:`Composition` - классы для работы с
  материалами

* :code:`Transformation` - задает трансформацию геометрии

* :code:`Shape`, :code:`Body` - для работы с ячейками

* :code:`Plane`, :code:`Sphere`, :code:`Cylinder`, :code:`Cone`, :code:`Torus`,
  :code:`GQuadratic` - для работы с поверхностями.

* :code:`FMesh` - для работы с сетками - рузультаты расчетов

* и другие вспомогательные функции.

Все публичные функции, классы и их методы имеют встроенную документацию, которая
хранится в поле :code:`__doc__`. Справка по тому, что функция делает, и список
ее аргументов можно получить с помощью команды::

    print(mc.Cylinder.test_points.__doc__)


Создание новой геометрии
------------------------

В MCNP геометрия задается в функциональном представлении, т.е. как область
пространства, ограниченная набором поверхностей, задаваемых уравнениями. Поэтому
для того, чтобы создать геометрию надо сперва задать поверхности. Основная
функциия для создания поверхности в :code:`mckit` - :code:`create_surface`.
Она принимает в точности такие же аргументы, какие требуются для задания
поверхности в MCNP, а именно: спецификатор поверхности (PX, SO, C/X, и т.д),
список параметров, задающих коэффициенты в уравнении поверхности, и набор
параметров ключ-значение, задающих дополнительные опции. Например, чтобы
создать цилиндр, параллельный оси Y, смещенный по X на 3 и по Z на -2, радиусом
5 надо выполнить::

    cyl = mc.create_surface('C/Y', 3, -2, 5)

В качестве опций можно задать трансформацию::

    tr = mc.Transformation(translation=[1, 4, -2])
    cyl2 = mc.create_surface('C/X', 3, -2, 7, transform=tr)

Первая строчка создает объект трансформации геометрии, что является параллельным
переносом, задаваемым вектором [1, 4, -2].

Также поверхности можно задавать напрямую вызовом конструкторов соответствующих
классов. Но в этом случае, необходимые параметры могут отличаться от тех, что
использует MCNP. Так, например, чтобы создать цилиндр необходимо задать точку,
через которую проходит его ось, направление оси и радиус. Создадим цилиндр,
параллельный оси x, ось которого проходит через точку [1, 3, 2], и радиусом 6::

    cyl = mc.Cylinder([1, 3, 2], [1, 0, 0], 6)

Также как и в предыдущем случае, конструктору могут быть переданы опциональные
параметры.

У всех поверхностей есть методы :code:`test_box` и :code:`test_points`. Для нас
будет интересен только последний. Он принимает на вход либо координаты одной
точки, либо массива точек и проверяет, по какую сторону от поверхности они
расположены. Если точка расположена со стороны положительной нормали к
поверхности, то данный метод вернет :code:`+1`; если же с противоположной
стороны, то :code:`-1`. Если на вход подан массив точек, то будет возвращен
массив результатов теста для каждой точки::

    import numpy as np
    points = np.array([[0, 0, 0], [1, 3, 2], [10, 21, 40]])
    result = cyl.test_points(points)
    print(result)

Теперь научимся комбинировать поверхности для описания геометрии ячеек. За
описание геометрии (формы) отвечает класс :code:`Shape`. Он описывает только
форму. Его конструктор принимает переменное число параметров. Первый их них
это всегда спецификатор операции, который задает что сделать с остальными
аргументами - создать пересечение, объединение или дополнение:

* :code:`'I'` - к аргументам будет применена операция пересечения. Аргументов
  может быть 2 и более.

* :code:`'U'` - операция объединения. Аргументов может быть два и больше.

* :code:`'C'` - операция дополнения - допустим только один аргумент.

* :code:`'S'` - нет операции, тождество - допустим только один аргумент.

Аргументами могут быть любые объекты классов :code:`Shape` или :code:`Surface`
(это абстрактный класс, т него унаследованы все классы поверхностей). Для
демонстрации создадим одну форму, которая является областью внутри сферы
радиусом 5, а потом, с помощью нее форму, которая является пространством между
сферами 5 и 10::

    sph5 = mc.Sphere([0, 0, 0], 5)     # Сфера радиусом 5
    shape1 = mc.Shape('C', sph5)       # форма - внутри сферы 5
    sph10 = mc.create_sphere('SO', 10) # сфера радиусом 10
    shape2 = mc.Shape('C', sph10)      # форма - внутри сферы радиусом 10
    outer = shape1.complement()        # форма, дополнение к shape1 - пространство
                                       # снаружи сферы радиусом 5
    shape3 = mc.Shape('I', shape2, outer) # форма - между сферами радиусом 5 и 10.

Обратите внимание, что мы использовали во второй строчке оператор дополнения
:code:`'C'` с поверхностью - это означает, что мы берем полупространство,
которое лежит с отрицательной стороны нормали. В четвертой строке мы создаем
форму, которая является внутренним пространством сферы радиусом 10. Далее берем
дополнение для shape1, и в конце делаем пересечение shape2 и outer. Также
форму :code:`outer` можно было создать по-другому, а пересечение создать
используя метод :code:`intersection` класса :code:`Shape`::

    outer = mc.Shape('S', sph5)  # пространство снаружи сферы.
    shape3 = shape2.intersection(outer)

Также класс :code:`Shape` имеет следующие полезные методы:

* :code:`test_points(points)` - тут все аналогично одноименному методу
  поверхности. Резульата +1, если точка лежит внетри формы, -1 - если снаружи,
  и 0, что большая редкость, если попадет на границу.

* :code:`volume(box, min_volume)` - расчитывает объем, занимаетмый формой.

* :code:`bounding_box(box, tol)` - расчитывает параллепипед, ограничивающий
  форму.

* :code:`union` - Объединение формы с другими

* :code:`intersection` - пересечение формы с другими

* :code:`complement` - дополнение к форме.


Работа с материалами
--------------------

Данный функционал позволяет создавать и редактировать материалы, а также
создавать материалы как смеси других в различных пропорциях. Пакет включает
следующие классы:

* :code:`Element` - описывает отдельный элемент. В принципе, редко когда
  пригодиться.

* :code:`Composition` - описывает состав материала - пропорции различных
  элементов. Он не задает плотность материала, т.е. плотность может быть
  любой. Напрямую соответствуюет материалу в MCNP.

* :code:`Material` - описывает материал, с составом и плотностью, как он
  должен быть в реальности.

Чтобы сосздать экземпляр класса :code:`Composition` надо передать конструктору
список изотопов и их доли (массовые или атомные). Если доли массовые, то список
передается параметру :code:`weight`, если атомные, то :code:`atomic`. Создадим
состав воды::

    elements = [('H', 2), ('O', 1)]  # На 2 атома водорода приходится 1 ат кислорода
    water = mc.Composition(atomic=elements)

Названия элементов могут передаваться как химические обозначения (например
'H', 'Ca', 'Ar-40', если масса не указывается, то элемент считается с природным
изотопным составом) или в виде числа в формате Z*1000 + A, где Z - заряд ядра,
A - атомный номер (например 1001 водород-1, 8016 - кислород-16, 8000 - кислород
с природным изотопным составом). Массовые доли не обязаны быть нормализованными.

Полезные методы:

* :code:`molar_mass` - свойство, молярная масса. Молекулярные связи не
  принимаются в рассмотрение, поэтому молярная масса отличается от табличного
  значения для некоторых веществ (например, для воды).

* :code:`expand()` - получает композицию с детальным изотопным составом.
  Все элементы с природным изотопным составом заменяются на соответствующие
  изотопы.

* :code:`natural(tolerance)` - проверяет, имеют ли изотопы природный состав, и
  если да, то возвращается композиция без детального изотопного состава.
  Этот метод обратный к предыдущему.

* :code:`mixture(*compositions)` - создает новую композицию как смесь
  приведенных.

Например, создадим вещество, где половина 30% атомов - вода, а другая половина -
железо::

    fe = mc.Composition(atomic=[('Fe', 1)])
    mix = mc.Composition.mixture((water, 0.3), (fe, 0.7))

Этот метод редко когда будет нужен, поскольку необходимо смешивать  реальные
вещества, со своей плотностью.

Чтобы создать реальное вещество нужно использовать класс :code:`Material`.
Ему в качестве аргументов можно передать либо готовую композицию, либо состав,
а также плотность или концентрацию атомов. Создадим реальную воду::

    real_water1 = mc.Material(composition=water, density=1.0)
    real_water2 = mc.Material(atomic=[('H', 2), ('O', 1)], density=1.0)
    real_iron = mc.Material(composition=fe, density=7.8)

Этот класс имеет свой статический метод :code:`mixture(*materials, fraction_type)`,
второй аргумент которого указывает какой тип долей используется: массовый,
объемный, или атомный. В случае с объемными долями если доли не нормированны на
1, то это либо добавляет пустого пространства (если сумма меньше 1), либо
уплотняет материал (если больше 1). Для атомных и массовых долей все равно
проводится нормировка на 1. В качестве примера создадим водку (40% объемная
доля спирта):

    water = mc.Material(atomic=[('H', 2), ('O', 1)], density=1.0)
    ethanol = mc.Material(atomic=[('C', 2), ('O', 1), ('H', 6)], density=0.79)
    vodka = mc.Material.mixture((water, 0.6), (ethanol, 0.4), fraction_type='volume')


Чтение MCNP модели
------------------

Любая модель MCNP пердставляется в виде экземпляра класса :code:`Universe`.
Для чтения MCNP-модели из файла есть функция :code:`from_file(filename)`::

    from mckit.parser import from_file, ParseResult

    result: ParseResult = from_file('model.i')
    model: Universe = result.universe

Имеются также вспомогательные методы чтения из текста и потока :code:`from_text`, :code:`from_stream`.
После этого будет создан экземпляр класса :code:`Universe`, который позволяет
проводить дальнейшие манипуляции с моделью. Можно получить список всех вложенных
юниверсов с помощью метода :code:`get_universes()`. Он вернет список имен всех
вложенных юниверсов. Затем можно получить объект вложенного юниверса по имени:
:code:`select_universe(name)`.


Упрощение геометрии
-------------------

Чтение результатов MCNP расчета
-------------------------------

Расчет активации
----------------

Shut-down dose rate
-------------------
